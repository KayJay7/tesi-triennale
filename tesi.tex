\documentclass{article}
\usepackage{authblk}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{float}
\usepackage[pdfa]{hyperref}
\usepackage{indentfirst}
\usepackage{pdfpages}

% stile per i blocchi di codice
% non so se serviranno
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
% fine stile

\newcommand{\michele}[1]{{\color{red}Michele:~}{\itshape``{#1}''}}

\begin{titlepage}
    \title{Analisi di scalabilità dell'implementazione in Golang del calcolo AbU}
    \author{Bruniera Alvise}
    \affil{Università degli studi di Udine}
    \date{\today}
\end{titlepage}

\begin{document}
\maketitle

\newpage
\begin{abstract}
    `GoAbU' è un'implementazione del calcolo `AbU' (Attribute-based memory Updates) per programmare sistemi distribuiti di piccoli dispositivi IoT. In questa tesi ci poniamo l'obbiettivo di studiarne il comportamento all'aumentare del numero di nodi, sotto diversi tipi di carico, utilizzando il simulatore `abusim'. Quindi stabilire un metodo ragionevole e realizzare degli strumenti, per analizzare il comportamento di `goabu'.\\
    A questo scopo abbiamo realizzato alcuni programmi e script. In particolare `aeg' per generare parametricamente configurazioni per il simulatore, in modo da creare più facilmente configurazioni complesse con numero variabile di nodi, anche centinaia. Ed una serie di script per misurare il traffico di rete di ogni nodo (in termini di quantità di byte e pacchetti) ed il traffico riportato a livello di transazioni da uno dei nodi (quantità di byte e di transazioni), e per estrarre grafici e metriche utili da questi dati.\\
    Abbiamo analizzato il traffico per 10, 50 e 100 nodi, sotto tre tipi di carico: nessun carico (idle), carico alto ma realistico (medio), carico molto alto (alto). In tutti i casi, con solo 10 nodi il carico è accettabile.\\
    Il traffico è risultato molto alto sia sotto carico medio che alto, in particolare, sotto carico alto, diventava problematico già da 50 dispositivi. Tuttavia, confrontando i risultati con il traffico riportato a livello di libreria da `goabu', risulta che la compressione svolta dal middleware riesce a rendere il traffico molto minore di quanto potrebbe essere.

    % mai buttare via niente ;)
    %  In idle, il numero di dispositivi non sembra influire molto sul traffico della rete, sia il numero di pacchetti che di byte resta molto basso, anzi diminuisce la dimensione media dei pacchetti. Sotto carico medio, il numero di nodi influenza in modo quadratico il carico della rete, inoltre, 50 dispositivi sono sufficienti a generare circa 2 GB di traffico, mentre 100 si avvicinano ai 10 GB, posiamo aspettarci di vedere questo tipo di traffico in applicazioni reali. Sotto carico alto, anche se con 10 nodi il traffico è accettabile (300 MB), è comunque 5 volte più alto del carico medio. Con più nodi invece diventa insostenibile già a 50 nodi, paragonabile al traffico del carico medio con 100 nodi; quando si arriva a 100 nodi supera i 15 GB di traffico ed uno dei benchmark è arrivato fino a 25. \michele{Non andrei così in dettaglio nell'abstract, metterei solo un riassunto di cosa vogliamo testare (senza numeri)} \\
    % , con rapporto di compressione tra il 2,2 ed il 2,6
\end{abstract}

\newpage
\tableofcontents

\newpage
\section{Il calcolo AbU}

AbU~\cite{MP-ICTAC-2021} (Attribute-based memory Updates) è un paradigma di calcolo distribuito basato sull'utilizzo di regole ECA (event-condition-action) per sincronizzare e scambiare informazioni tra grandi quantità di nodi.\\
Le regole non sono molto diverse da delle normali ECA: ogni regola è legata ad una variabile del nodo, e quando questa variabile viene modificata (da una regola o da un dispositivo di input), se una condizione specificata è verificata, esegue l'azione.
La caratteristica che distingue AbU è la possibilità di specificare regole ``esterne'', che agiscano sulle variabili degli altri nodi del sistema. Una regola esterna può specificare condizioni sia su variabili locali che esterne, mentre nelle azioni possono specificare solo variabili esterne. Un'azione avrà effetti su un nodo solo se possiede tutte le variabili esterne menzionate nella regola.
Utilizzando queste regole, la memoria dei nodi viene aggiornata in base ad i suoi attributi (le variabili che possiede il nodo) da cui il nome.\\
In questo modo, è possibile programmare un sistema distribuito completamente disaccoppiato nello spazio, poiché l'effetto di un'azione sugli altri nodi dipende da loro attributi e non richiede di conoscere la posizione delle variabili.

\href{https://github.com/abu-lang/goabu}{GoAbU} è un'implementazione di questo modello di calcolo scritta in linguaggio go.
È costruita utilizzando la libreria \href{https://github.com/hashicorp/memberlist}{memberlist} come middleware per la comunicazione in gruppo e la scoperta dei nodi, ed il framework \href{https://github.com/hybridgroup/gobot/}{gobot} per renderla utilizzabile in ambito IoT.\\
Il focus principale della tesi sarà sia definire un metodo di test ragionevole e riproducibile per testare un'implementazione del calcolo AbU (e gli strumenti per eseguire test), che un'analisi di GoAbU stesso.

Durante lo sviluppo dei test abbiamo incontrato due limitazioni del linguaggio, una delle quali facilmente risolvibile una volta definita la semantica di una funzionalità aggiuntiva, l'altra invece potrebbe eventualmente essere mitigata ma non risolta del tutto.\\
Il linguaggio non ammette che le regole esterne eseguano azioni sulle variabili locali. Questo è in parte perché se le regole impostassero una variabile locale al valore di una esterna, il valore finale della variabile locale non solo dipenderebbe dagli agenti esterni, ma anche dall'ordine in uci eseguono le azioni. Tuttavia, questo problema non sussiste se nel right-hand-side dell'assegnamento compaiono solo costanti e variabili locali. Tuttavia, permettere questa funzionalità (che aiuterebbe nella scrittura dei programmi) richiede di rivedere la semantica delle azioni esterne, per decidere in che momento va eseguita l'azione.\\
% supercazzola che probabilmente bisognerà ridurre
L'altro problema invece riguarda la consistenza del sistema. Per il CAP theorem~\cite{brewer2000towards}, sappiamo che un sistema distribuito non può essere contemporaneamente ``consistente'', ``resistente alla partizione'' e ``disponibile''; AbU è sia resistente che disponibile, quindi non si può ottenere consistenza, ed anche la consistenza eventuale sarebbe fuori dagli obbiettivi del paradigma.
% veramente il problema di cui voglio parlare
Tuttavia è particolarmente suscettibile al problema dei lost update. Nello specifico, se ad esempio un nodo \lstinline{foo} possiede la variabile intera \lstinline{x = 0} (e nessun altro nodo la possiede) $n$ nodi causano (con successo) l'esecuzione di una azione esterna del tipo \lstinline{ext.x = ext.x + 1;}, il valore di \lstinline{x} al termine dell'esecuzione delle azioni, il valore di \lstinline{x} sarà contenuto in $0..n$, ma l'effettivo valore dipenderà interamente dal momento in cui le $n$ azioni vengono inserite nella coda degli eventi di \lstinline{foo}.
Come annunciato in precedenza non si può rendere AbU completamente consistente, quindi già a prescindere non è mai garantito che tutti gli update abbiano effetto. Tuttavia nella situazione attuale, anche quando la rete funziona correttamente, non è possibile implementare un contatore ``affidabile'' che venga incrementato da più nodi.\\
Entrambi questi problemi non rientrano nell'obbiettivo della tesi, ma sono venuti alla luce perché per la prima volta il calcolo AbU è stato usato per qualcosa al di fuori di uno showcase. Quindi era il caso di esporli.

\section{Setting sperimentale}

I test sono stati eseguiti utilizzando il ``simulatore'' \href{https://github.com/abu-lang/abusim}{AbUsim}. Si basa sull'utilizzo di docker ed è progettato sulla falsa riga di docker compose, ovvero preso in input un file yml che descrive una serie di container, li avvia e mette in comunicazione.
I file di configurazione di `AbUsim' permettono di specificare un elenco di dispositivi che eseguiranno `goAbU'. Ogni dispositivo ha un suo elenco di variabili (che possono essere inizializzate arbitrariamente) ed un elenco di regole in linguaggio `AbU'.
Per comodità è possibile specificare un prototipo in ogni dispositivo. I prototipi specificano anch'essi un elenco di regole e di variabili che i dispositivi erediteranno. In questo modo si possono raggruppare regole in comune tra tanti dispositivi.
Si possono configurare anche il tick time (il tempo che il dispositivo aspetterà tra le esecuzioni delle regole) e l'immagine docker da usare per i nodi ed il coordinatore.

Il parsing delle regole di ogni nodo viene fatto direttamente dal simulatore, che dopo aver costruito l'elenco di regole e variabili di ogni nodo, codificherà gli alberi di sintassi in \lstinline{json} e successivamente in \lstinline{base64} per passarli come argomenti al programma in esecuzione su ogni nodo, questa informazione sarà utile più avanti. È possibile collegare altri nodi esterni alla rete del simulatore che eseguano goAbU, ma non è necessario per questa tesi.\\
Viene avviato anche un coordinatore, che gestisce la comunicazione con l'esterno sia per inviare comandi che per ricevere log. Questo è strettamente parte del simulatore e non un elemento che ci si aspetta tri trovare in una reale applicazione di AbU, che invece è pensato per essere decentralizzato. Va notato, allo scopo del progetto, che la rete virtuale su cui viaggiano i messaggi di goAbU è separata da quella su cui viaggiano i messaggi di gestione ed i log.\\
Opzionalmente si può avviare un container che offre un'interfaccia web per controllare i nodi, verificandone lo stato ed inviando comandi. Tutto ciò può essere fatto anche programmaticamente tramite una libreria python.

\michele{Farei poi un'ulteriore sezione, magari chiamata `Setting Sperimentale', dove spiegherei il simulatore ed i problemi riscontrati}

\subsection{Problemi secondari}


\begin{itemize}
    \item Limite alla dimensione della configurazione di goabu
    \item Se un nodo muore, il logger occupa una cpu al 100\%
    \item Tempo di compilazione delle regole
    \item Altro se mi viene in mente
\end{itemize}

\section{Generazione dei test}

aeg

\michele{Forse chiamerei la sezione qualcosa del tipo `Generazione di Test', e come prima cosa spiegherei il tool che hai sviluppato}

\subsection{Configurazioni parametriche}

Qua parlo di come sono strutturati i test generati con aeg e che parametri si possono variare.

\subsection{Scelta delle configurazioni}

Qua parlo di cosa volevo ottenere dalle configurazioni e come ho scelto i parametri.

\section{Raccolta dati}

\subsection{Ispezione dei nodi}

Qua parlo di come raccoglie i dati lo script, e quali informazioni ottengo dai log.

\subsection{Metriche}

Elenco delle metriche.

Parlo più nel dettaglio solo delle metriche che ci interessano di più.

\section{Risultati}

Qua metto solo i grafici sulle metriche più importanti di cui ho parlato prima.

\ref{appendix:grafici}

\subsection{Osservazioni}

Spiego le informazioni ottenute dai grafici, quindi espando un po' di quello che è già nell'abstract \\

\michele{Gli altri grafici li metterei come appendice, da inserire dopo la bibliografia}



\bibliographystyle{plain}
\bibliography{biblio}

\appendix

\section{Altri grafici}\label{appendix:grafici}

Il resto dei grafici

\end{document}